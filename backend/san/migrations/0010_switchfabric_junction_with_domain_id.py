# Generated by Django 5.1.6 on 2025-10-24 02:48

import django.core.validators
import django.db.models.deletion
from django.db import migrations, models


def migrate_fabric_switches_to_switchfabric(apps, schema_editor):
    """
    Migrate existing switch-fabric relationships from the auto-generated
    san_fabric_switches table to the new SwitchFabric model.
    Domain IDs will be null as existing domain_id values are being discarded.
    """
    # We can't import the model directly as it may be a future version
    # Instead, we use the historical models
    Fabric = apps.get_model('san', 'Fabric')
    Switch = apps.get_model('san', 'Switch')
    SwitchFabric = apps.get_model('san', 'SwitchFabric')

    # Get all existing switch-fabric relationships from the old M2M table
    # by accessing the switches field before it's altered
    for fabric in Fabric.objects.prefetch_related('switches').all():
        for switch in fabric.switches.all():
            # Create SwitchFabric entry with domain_id = null
            SwitchFabric.objects.create(
                switch=switch,
                fabric=fabric,
                domain_id=None
            )

    print(f"âœ… Migrated {SwitchFabric.objects.count()} switch-fabric relationships")


def reverse_migrate_switchfabric_to_fabric_switches(apps, schema_editor):
    """
    Reverse migration: This will be handled automatically by Django
    when removing the SwitchFabric entries and restoring the old M2M table.
    """
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('san', '0009_fabric_switch_manytomany'),
    ]

    operations = [
        # Step 1: Remove domain_id from Fabric (we're discarding these values)
        migrations.RemoveField(
            model_name='fabric',
            name='domain_id',
        ),

        # Step 2: Create the new SwitchFabric junction model
        migrations.CreateModel(
            name='SwitchFabric',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('domain_id', models.IntegerField(blank=True, help_text="Switch's domain ID within this fabric (0-999)", null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(999)])),
                ('fabric', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='fabric_switches', to='san.fabric')),
                ('switch', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='switch_fabrics', to='san.switch')),
            ],
            options={
                'verbose_name': 'Switch-Fabric Assignment',
                'verbose_name_plural': 'Switch-Fabric Assignments',
                'ordering': ['fabric', 'switch'],
                'unique_together': {('fabric', 'domain_id'), ('switch', 'fabric')},
            },
        ),

        # Step 3: Migrate existing switch-fabric data BEFORE removing the old field
        migrations.RunPython(
            migrate_fabric_switches_to_switchfabric,
            reverse_migrate_switchfabric_to_fabric_switches,
        ),

        # Step 4: Remove the old switches M2M field
        migrations.RemoveField(
            model_name='fabric',
            name='switches',
        ),

        # Step 5: Re-add the switches field with the through table
        migrations.AddField(
            model_name='fabric',
            name='switches',
            field=models.ManyToManyField(blank=True, help_text='Switches this fabric belongs to', related_name='fabrics', through='san.SwitchFabric', to='san.switch'),
        ),
    ]
