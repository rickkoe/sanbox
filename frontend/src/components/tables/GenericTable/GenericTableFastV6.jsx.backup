import React, { useState, useMemo, useCallback, useEffect, forwardRef, useImperativeHandle, useRef } from 'react';
import { useTable, useSortBy, usePagination as useTablePagination, useRowSelect, useGlobalFilter, useFilters } from 'react-table';
import axios from 'axios';
import { useTheme } from '../../../context/ThemeContext';
import { getEditorForColumn } from './components/FastEditors';
import { getFormatterForColumn } from './components/FastFormatters';
import { generateTableColumns, convertLegacyColumns } from './utils/columnUtils';
import { usePagination } from './hooks/usePagination';
import TableToolbar from './components/TableToolbar';
import PaginationFooter from './components/PaginationFooter';
import QuickSearch from './components/QuickSearch';
import AdvancedFilter from './components/AdvancedFilter';
import StatsContainer from './components/StatsContainer';
import './GenericTableFast.css';
import './components/TableToolbar.css';

/**
 * GenericTableFast - High-performance table using react-table v7
 * 
 * This component provides the same API as GenericTable but with excellent performance:
 * - Headless table logic with custom rendering
 * - Built-in sorting, filtering, pagination
 * - No heavy Handsontable overhead
 * - Modern React patterns
 * - Flexible column structure for optimal performance
 */

// Editable cell component for react-table v7
const EditableCell = ({ value: initialValue, row: { index }, column: { id, editorOptions }, updateData }) => {
  const [value, setValue] = useState(initialValue || '');
  const [isEditing, setIsEditing] = useState(false);
  const [showDropdown, setShowDropdown] = useState(false);
  const inputRef = useRef();
  const dropdownRef = useRef();

  const options = editorOptions?.options || [];
  const isDropdown = options.length > 0;
  const isCheckbox = editorOptions?.type === 'checkbox';

  useEffect(() => {
    setValue(initialValue || '');
  }, [initialValue]);

  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      if (!isCheckbox) {
        inputRef.current.select();
      }
    }
  }, [isEditing, isCheckbox]);

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setShowDropdown(false);
        if (isEditing) {
          onBlur();
        }
      }
    };

    if (isEditing) {
      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }
  }, [isEditing]);

  const onBlur = () => {
    setIsEditing(false);
    setShowDropdown(false);
    updateData(index, id, value);
  };

  const onChange = (e) => {
    const newValue = isCheckbox ? e.target.checked : e.target.value;
    setValue(newValue);
    if (isCheckbox) {
      updateData(index, id, newValue);
      setIsEditing(false);
    }
  };

  const onKeyDown = (e) => {
    if (e.key === 'Enter') {
      onBlur();
    } else if (e.key === 'Escape') {
      setValue(initialValue || '');
      setIsEditing(false);
      setShowDropdown(false);
    }
  };

  const handleOptionClick = (option) => {
    setValue(option);
    setShowDropdown(false);
    setIsEditing(false);
    updateData(index, id, option);
  };

  const filteredOptions = options.filter(option =>
    option.toLowerCase().includes(String(value).toLowerCase())
  );

  if (isCheckbox) {
    return (
      <div className="table-cell-checkbox" onClick={() => setIsEditing(true)}>
        {isEditing ? (
          <input
            ref={inputRef}
            type="checkbox"
            checked={Boolean(value)}
            onChange={onChange}
            onBlur={onBlur}
            style={{ transform: 'scale(1.2)' }}
          />
        ) : (
          <span style={{
            color: value ? '#fff' : '#6c757d',
            backgroundColor: value ? '#28a745' : 'transparent',
            fontSize: '12px',
            padding: '2px 6px',
            borderRadius: '10px',
            fontWeight: 'bold'
          }}>
            {value ? '‚úì Yes' : '‚úó No'}
          </span>
        )}
      </div>
    );
  }

  return (
    <div className="table-cell-editable" ref={dropdownRef}>
      {isEditing ? (
        <div style={{ position: 'relative', width: '100%' }}>
          <input
            ref={inputRef}
            value={value}
            onChange={onChange}
            onBlur={onBlur}
            onKeyDown={onKeyDown}
            onFocus={() => isDropdown && setShowDropdown(true)}
            style={{
              width: '100%',
              border: '1px solid #007bff',
              borderRadius: '3px',
              padding: '4px 8px',
              fontSize: '14px',
              outline: 'none'
            }}
          />
          {isDropdown && showDropdown && filteredOptions.length > 0 && (
            <div style={{
              position: 'absolute',
              top: '100%',
              left: 0,
              right: 0,
              maxHeight: '200px',
              overflowY: 'auto',
              backgroundColor: '#fff',
              border: '1px solid #ced4da',
              borderTop: 'none',
              zIndex: 1000,
              boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
            }}>
              {filteredOptions.map((option, index) => (
                <div
                  key={option}
                  onClick={() => handleOptionClick(option)}
                  style={{
                    padding: '8px 12px',
                    cursor: 'pointer',
                    backgroundColor: 'transparent',
                    borderBottom: index < filteredOptions.length - 1 ? '1px solid #f1f3f4' : 'none',
                    fontSize: '14px'
                  }}
                  onMouseEnter={(e) => {
                    e.target.style.backgroundColor = '#e7f3ff';
                  }}
                  onMouseLeave={(e) => {
                    e.target.style.backgroundColor = 'transparent';
                  }}
                >
                  {option}
                </div>
              ))}
            </div>
          )}
        </div>
      ) : (
        <div
          onClick={() => setIsEditing(true)}
          style={{
            width: '100%',
            height: '100%',
            padding: '8px',
            cursor: 'pointer',
            minHeight: '34px',
            display: 'flex',
            alignItems: 'center'
          }}
        >
          {getFormattedValue(value, id)}
        </div>
      )}
    </div>
  );
};

// Formatting helper function
const getFormattedValue = (value, columnId) => {
  if (value === null || value === undefined || value === '') {
    return <span style={{ color: '#dee2e6', fontStyle: 'italic', fontSize: '12px' }}>‚Äî</span>;
  }

  if (columnId === 'zone_status' || columnId === 'status') {
    if (value === 'valid') return <span style={{ color: '#28a745', fontSize: '16px', fontWeight: 'bold' }}>‚úÖ Valid</span>;
    if (value === 'invalid') return <span style={{ color: '#dc3545', fontSize: '16px', fontWeight: 'bold' }}>‚ùå Invalid</span>;
    return <span style={{ color: '#6c757d' }}>{value || 'Unknown'}</span>;
  }

  if (columnId === 'member_count') {
    const count = parseInt(value) || 0;
    return (
      <div style={{ textAlign: 'center' }}>
        <span style={{
          color: count > 0 ? '#28a745' : '#6c757d',
          fontWeight: count > 0 ? 'bold' : 'normal',
          backgroundColor: count > 0 ? '#d4edda' : '#f8f9fa',
          padding: '2px 8px',
          borderRadius: '12px',
          fontSize: '12px'
        }}>
          {count} members
        </span>
      </div>
    );
  }

  if (columnId === 'fabric') {
    const hasValue = value && value.trim() !== '';
    return (
      <span style={{
        color: hasValue ? '#0d6efd' : '#6c757d',
        fontWeight: hasValue ? '600' : '400',
        backgroundColor: hasValue ? '#e7f3ff' : '#f8f9fa',
        padding: '4px 8px',
        borderRadius: '6px',
        border: hasValue ? '1px solid #b3d7ff' : '1px solid #e9ecef',
        fontSize: '13px',
        display: 'inline-block'
      }}>
        {hasValue ? value : 'No Fabric'}
      </span>
    );
  }

  if (columnId === 'name') {
    return <span style={{
      fontWeight: '600',
      color: value ? '#212529' : '#6c757d'
    }}>{value || 'Unnamed'}</span>;
  }

  if (columnId && columnId.startsWith('member_')) {
    const hasValue = value && value.trim() !== '';
    return (
      <div style={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'flex-start',
        height: '100%',
        width: '100%'
      }}>
        <span style={{
          color: hasValue ? '#0d6efd' : '#dee2e6',
          fontStyle: hasValue ? 'normal' : 'italic',
          fontSize: '12px',
          fontWeight: hasValue ? '500' : '400',
          backgroundColor: hasValue ? '#e7f3ff' : '#f8f9fa',
          padding: '3px 6px',
          borderRadius: '4px',
          border: hasValue ? '1px solid #b3d7ff' : '1px solid #e9ecef',
          minWidth: hasValue ? 'auto' : '30px',
          textAlign: 'center',
          display: 'inline-block'
        }}>
          {hasValue ? value : '‚Äî'}
        </span>
      </div>
    );
  }

  if (columnId === 'notes') {
    const truncated = value && value.length > 30 ? value.substring(0, 30) + '...' : value;
    return (
      <span
        style={{
          color: '#6c757d',
          fontStyle: value ? 'normal' : 'italic',
          fontSize: '12px'
        }}
        title={value}
      >
        {truncated || 'No notes'}
      </span>
    );
  }

  if (typeof value === 'boolean') {
    return <span style={{ color: value ? '#28a745' : '#dc3545' }}>{value ? 'Yes' : 'No'}</span>;
  }

  if (value instanceof Date) {
    return <span style={{ fontSize: '13px' }}>{value.toLocaleDateString()}</span>;
  }

  return <span style={{ fontSize: '13px' }}>{String(value)}</span>;
};

// Selection checkbox component
const IndeterminateCheckbox = React.forwardRef(
  ({ indeterminate, ...rest }, ref) => {
    const defaultRef = useRef();
    const resolvedRef = ref || defaultRef;

    useEffect(() => {
      resolvedRef.current.indeterminate = indeterminate;
    }, [resolvedRef, indeterminate]);

    return (
      <input
        type="checkbox"
        ref={resolvedRef}
        {...rest}
        style={{ transform: 'scale(1.2)' }}
      />
    );
  }
);

const GenericTableFast = forwardRef(({
  // Data props
  apiUrl,
  data: externalData,
  
  // Column configuration  
  columns = [],
  colHeaders = [],
  dropdownSources = {},
  customRenderers = {},
  customEditors = {},
  
  // Table behavior
  newRowTemplate = {},
  serverPagination = false,
  defaultPageSize = 25,
  tableName = 'generic', // For auto-column generation
  
  // URLs for save/delete
  saveUrl,
  deleteUrl,
  
  // Callbacks
  onSave,
  beforeSave,
  afterSave,
  onDelete,
  preprocessData,
  onBuildPayload,
  
  // Export
  getExportFilename,
  
  // Dynamic columns (for zone table)
  memberCount = 20,
  visibleBaseIndices,
  
  // Column actions (dropdown for column operations)
  columnActions = [],
  
  // Other props
  height = '600px',
  className = '',
  
}, ref) => {
  const { theme } = useTheme();
  
  // State management
  const [rows, setRows] = useState([]);
  const [loading, setLoading] = useState(false);
  const [selectedRows, setSelectedRows] = useState(new Set());
  const [isDirty, setIsDirty] = useState(false);
  const [serverTotalCount, setServerTotalCount] = useState(0);
  
  // Filter and search state
  const [quickSearch, setQuickSearch] = useState('');
  const [columnFilters, setColumnFilters] = useState({});
  const [filteredData, setFilteredData] = useState([]);
  
  // Pagination state (only for client-side pagination)
  const pagination = usePagination(
    filteredData, 
    defaultPageSize || 25,
    `${tableName}_pagination`,
    null // No global page size change handler for now
  );
  
  // Debug pagination
  useEffect(() => {
    console.log('üìä Pagination state:', {
      filteredDataLength: filteredData.length,
      currentPage: pagination.currentPage,
      totalPages: pagination.totalPages,
      pageSize: pagination.pageSize,
      startRow: pagination.startRow,
      endRow: pagination.endRow
    });
  }, [filteredData.length, pagination]);

  // Fetch data from API
  const fetchData = useCallback(async () => {
    if (!apiUrl && !externalData) return;
    
    if (externalData) {
      const processedData = preprocessData ? preprocessData(externalData) : externalData;
      setRows(processedData);
      return;
    }
    
    setLoading(true);
    try {
      // For client-side pagination, request all data by adding page_size parameter
      const fullApiUrl = serverPagination ? apiUrl : `${apiUrl}${apiUrl.includes('?') ? '&' : '?'}page_size=10000`;
      console.log('üöÄ GenericTableFast: Fetching data from', fullApiUrl);
      const response = await axios.get(fullApiUrl);
      const responseData = response.data;
      
      console.log('üì° API Response structure:', {
        isArray: Array.isArray(responseData),
        hasResults: !!responseData.results,
        hasCount: !!responseData.count,
        hasTotal: !!responseData.total,
        responseKeys: Object.keys(responseData),
        responseData: responseData
      });
      
      // Handle both array and paginated responses
      const dataArray = Array.isArray(responseData) ? responseData : responseData.results || [];
      const processedData = preprocessData ? preprocessData(dataArray) : dataArray;
      
      // Capture total count from server response
      const totalCount = responseData.count || responseData.total || dataArray.length;
      setServerTotalCount(totalCount);
      
      setRows(processedData);
      console.log('‚úÖ GenericTableFast: Loaded', processedData.length, 'rows of', totalCount, 'total');
    } catch (error) {
      console.error('‚ùå GenericTableFast: Error fetching data:', error);
      setRows([]);
      setServerTotalCount(0);
    } finally {
      setLoading(false);
    }
  }, [apiUrl, externalData, preprocessData]);

  // Load data on mount and when dependencies change
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  // Apply filters when data or filters change
  useEffect(() => {
    let filtered = [...rows];
    
    console.log('üîç GenericTableFast: Applying filters', {
      totalRows: rows.length,
      quickSearch,
      columnFilters,
      hasFilters: Object.keys(columnFilters).length > 0
    });
    
    // Apply quick search
    if (quickSearch) {
      const searchLower = quickSearch.toLowerCase();
      filtered = filtered.filter(row => 
        Object.values(row).some(value => 
          String(value || '').toLowerCase().includes(searchLower)
        )
      );
      console.log('üîç After quick search:', filtered.length);
    }
    
    // Apply column filters
    Object.entries(columnFilters).forEach(([columnKey, filterValue]) => {
      if (filterValue && filterValue !== '') {
        filtered = filtered.filter(row => {
          const cellValue = String(row[columnKey] || '').toLowerCase();
          const filterLower = String(filterValue).toLowerCase();
          return cellValue.includes(filterLower);
        });
        console.log(`üîç After ${columnKey} filter:`, filtered.length);
      }
    });
    
    console.log('üîç Final filtered data:', filtered.length);
    setFilteredData(filtered);
  }, [rows, quickSearch, columnFilters]);

  // Smart column generation
  const { finalColumns, finalHeaders } = useMemo(() => {
    console.log('üîß GenericTableFast: Building columns...');
    
    // Auto-generate columns if none provided
    if (columns.length === 0 && tableName !== 'generic') {
      console.log('üéØ Auto-generating columns for table:', tableName);
      const generated = generateTableColumns(tableName, { memberCount, visibleBaseIndices });
      return { finalColumns: generated.columns, finalHeaders: generated.headers };
    }
    
    // Use provided columns
    if (columns.length > 0) {
      const converted = convertLegacyColumns(columns, colHeaders);
      return { finalColumns: converted.columns, finalHeaders: converted.headers };
    }
    
    // Fallback
    return { finalColumns: [], finalHeaders: [] };
  }, [columns, colHeaders, tableName, memberCount, visibleBaseIndices]);

  // Convert to react-table v7 format with enhanced formatting and editors
  const reactTableColumns = useMemo(() => {
    console.log('üîß GenericTableFast: Converting', finalColumns.length, 'columns to react-table v7 format');
    
    return finalColumns.map((col) => {
      const column = {
        key: col.data,
        name: col.title,
        width: (col.width && col.width > 0) ? col.width : 120,
        resizable: true,
        sortable: !col.readOnly,
        editable: !col.readOnly
      };

      // Add editors for dropdown columns
      if (dropdownSources[col.data] && dropdownSources[col.data].length > 0) {
        column.editor = DropdownEditor;
        column.editorOptions = {
          options: dropdownSources[col.data]
        };
      }
      
      // Add checkbox editor for boolean columns
      if (col.type === 'checkbox' || col.data === 'create' || col.data === 'delete' || col.data === 'exists') {
        column.editor = CheckboxEditor;
      }

      // Enhanced formatters for better display
      if (col.data === 'zone_status' || col.data === 'status') {
        column.formatter = ({ value }) => {
          if (value === 'valid') return <span style={{ color: '#28a745', fontSize: '16px', fontWeight: 'bold' }}>‚úÖ Valid</span>;
          if (value === 'invalid') return <span style={{ color: '#dc3545', fontSize: '16px', fontWeight: 'bold' }}>‚ùå Invalid</span>;
          return <span style={{ color: '#6c757d' }}>{value || 'Unknown'}</span>;
        };
      } else if (col.data === 'member_count') {
        column.formatter = ({ value }) => {
          const count = parseInt(value) || 0;
          return (
            <div style={{ textAlign: 'center' }}>
              <span style={{ 
                color: count > 0 ? '#28a745' : '#6c757d',
                fontWeight: count > 0 ? 'bold' : 'normal',
                backgroundColor: count > 0 ? '#d4edda' : '#f8f9fa',
                padding: '2px 8px',
                borderRadius: '12px',
                fontSize: '12px'
              }}>
                {count} members
              </span>
            </div>
          );
        };
      } else if (col.data === 'fabric') {
        column.formatter = ({ value }) => {
          const hasValue = value && value.trim() !== '';
          return (
            <span style={{ 
              color: hasValue ? '#0d6efd' : '#6c757d',
              fontWeight: hasValue ? '600' : '400',
              backgroundColor: hasValue ? '#e7f3ff' : '#f8f9fa',
              padding: '4px 8px',
              borderRadius: '6px',
              border: hasValue ? '1px solid #b3d7ff' : '1px solid #e9ecef',
              fontSize: '13px',
              display: 'inline-block'
            }}>
              {hasValue ? value : 'No Fabric'}
            </span>
          );
        };
      } else if (col.data === 'name') {
        column.formatter = ({ value }) => {
          return <span style={{ 
            fontWeight: '600',
            color: value ? '#212529' : '#6c757d'
          }}>{value || 'Unnamed'}</span>;
        };
      } else if (col.data && col.data.startsWith('member_')) {
        column.formatter = ({ value }) => {
          const hasValue = value && value.trim() !== '';
          return (
            <div style={{ 
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'flex-start',
              height: '100%',
              width: '100%'
            }}>
              <span style={{ 
                color: hasValue ? '#0d6efd' : '#dee2e6',
                fontStyle: hasValue ? 'normal' : 'italic',
                fontSize: '12px',
                fontWeight: hasValue ? '500' : '400',
                backgroundColor: hasValue ? '#e7f3ff' : '#f8f9fa',
                padding: '3px 6px',
                borderRadius: '4px',
                border: hasValue ? '1px solid #b3d7ff' : '1px solid #e9ecef',
                minWidth: hasValue ? 'auto' : '30px',
                textAlign: 'center',
                display: 'inline-block'
              }}>
                {hasValue ? value : '‚Äî'}
              </span>
            </div>
          );
        };
      } else if (col.type === 'checkbox' || col.data === 'create' || col.data === 'delete' || col.data === 'exists') {
        column.formatter = ({ value }) => {
          const isTrue = Boolean(value);
          return (
            <div style={{ textAlign: 'center' }}>
              <span style={{ 
                color: isTrue ? '#fff' : '#6c757d',
                backgroundColor: isTrue ? '#28a745' : 'transparent',
                fontSize: '12px',
                padding: '2px 6px',
                borderRadius: '10px',
                fontWeight: 'bold'
              }}>
                {isTrue ? '‚úì Yes' : '‚úó No'}
              </span>
            </div>
          );
        };
      } else if (col.data === 'notes') {
        column.formatter = ({ value }) => {
          const truncated = value && value.length > 30 ? value.substring(0, 30) + '...' : value;
          return (
            <span 
              style={{ 
                color: '#6c757d',
                fontStyle: value ? 'normal' : 'italic',
                fontSize: '12px'
              }} 
              title={value}
            >
              {truncated || 'No notes'}
            </span>
          );
        };
      } else {
        // Default formatter with null/undefined handling
        column.formatter = ({ value }) => {
          if (value === null || value === undefined || value === '') {
            return <span style={{ color: '#dee2e6', fontStyle: 'italic', fontSize: '12px' }}>‚Äî</span>;
          }
          if (typeof value === 'boolean') {
            return <span style={{ color: value ? '#28a745' : '#dc3545' }}>{value ? 'Yes' : 'No'}</span>;
          }
          if (value instanceof Date) {
            return <span style={{ fontSize: '13px' }}>{value.toLocaleDateString()}</span>;
          }
          return <span style={{ fontSize: '13px' }}>{String(value)}</span>;
        };
      }

      return column;
    });
  }, [finalColumns, dropdownSources, customRenderers, customEditors]);

  // Handle row changes (editing)
  const handleRowsChange = useCallback((newRows, { indexes, column }) => {
    console.log('üìù GenericTableFast: Rows changed', { 
      affectedRows: indexes.length,
      column: column?.key 
    });
    
    setRows(newRows);
    setIsDirty(true);
  }, []);
  
  // Handle filter changes
  const handleFilterChange = useCallback((filters) => {
    setColumnFilters(filters);
    if (!serverPagination) {
      pagination.resetPagination();
    }
  }, [serverPagination, pagination]);

  // Handle row selection
  const handleSelectedRowsChange = useCallback((newSelectedRows) => {
    console.log('üìù Selection changed:', newSelectedRows);
    setSelectedRows(newSelectedRows);
  }, []);

  // Save functionality
  const handleSave = useCallback(async () => {
    if (!isDirty || (!onSave && !saveUrl)) {
      console.log('üíæ GenericTableFast: Save skipped - isDirty:', isDirty, 'hasHandlers:', !!(onSave || saveUrl));
      return;
    }
    
    try {
      console.log('üíæ GenericTableFast: Saving changes...', { 
        rowsToSave: rows.length,
        isDirty,
        hasOnSave: !!onSave,
        hasSaveUrl: !!saveUrl
      });
      setLoading(true);
      
      // Filter out empty rows and prepare data
      let dataToSave = rows.filter(row => {
        // Skip blank template rows
        if (row._isNew) return false;
        
        // Check if row has meaningful data (not just empty strings)
        return Object.values(row).some(value => 
          value !== null && value !== undefined && value !== ''
        );
      });

      // Apply custom payload transformation if provided
      if (onBuildPayload) {
        dataToSave = dataToSave.map(row => onBuildPayload(row));
      }

      if (beforeSave) {
        const validation = await beforeSave(dataToSave);
        if (validation !== true) {
          console.warn('‚ùå GenericTableFast: Save validation failed:', validation);
          return { success: false, message: validation };
        }
      }

      let result;
      
      if (onSave) {
        // Use custom save handler
        result = await onSave(dataToSave);
      } else if (saveUrl) {
        // Use default save with API
        const response = await axios.post(saveUrl, dataToSave);
        result = { success: true, data: response.data };
      }
      
      if (result && result.success !== false) {
        setIsDirty(false);
        console.log('‚úÖ GenericTableFast: Save successful');
        
        if (afterSave) {
          await afterSave(dataToSave);
        }
        
        // Refresh data
        await fetchData();
        
        return { success: true, message: 'Changes saved successfully!' };
      } else {
        throw new Error(result?.message || 'Save failed');
      }
    } catch (error) {
      console.error('‚ùå GenericTableFast: Save failed:', error);
      return { success: false, message: error.message };
    } finally {
      setLoading(false);
    }
  }, [rows, isDirty, onSave, saveUrl, beforeSave, afterSave, fetchData, onBuildPayload]);

  // Delete functionality
  const handleDelete = useCallback(async (rowsToDelete) => {
    if (!onDelete && !deleteUrl) return;
    
    try {
      console.log('üóëÔ∏è GenericTableFast: Deleting rows...', rowsToDelete.length);
      setLoading(true);
      
      let result;
      
      if (onDelete) {
        // Use custom delete handler
        result = await Promise.all(
          rowsToDelete.map(row => onDelete(row.id || row._id))
        );
      } else if (deleteUrl) {
        // Use default delete with API
        const deletePromises = rowsToDelete.map(row => 
          axios.delete(`${deleteUrl}${row.id}/`)
        );
        await Promise.all(deletePromises);
        result = [{ success: true }];
      }
      
      if (result && result.every(r => r.success !== false)) {
        console.log('‚úÖ GenericTableFast: Delete successful');
        
        // Remove deleted rows from state
        const deletedIds = new Set(rowsToDelete.map(row => row.id || row._id));
        setRows(prev => prev.filter(row => !deletedIds.has(row.id || row._id)));
        setSelectedRows(new Set());
        
        // Refresh data to ensure consistency
        await fetchData();
        
        return { success: true, message: `Deleted ${rowsToDelete.length} item(s) successfully!` };
      } else {
        throw new Error('Delete failed');
      }
    } catch (error) {
      console.error('‚ùå GenericTableFast: Delete failed:', error);
      return { success: false, message: error.message };
    } finally {
      setLoading(false);
    }
  }, [onDelete, deleteUrl, fetchData]);

  // Export functionality
  const handleExport = useCallback((format = 'csv') => {
    console.log('üìä GenericTableFast: Exporting as', format);
    
    const headers = reactDataGridColumns.map(col => col.name);
    const baseFilename = getExportFilename ? getExportFilename().replace(/\.[^/.]+$/, '') : 'table_export';
    
    if (format === 'csv') {
      const csvContent = [
        headers.join(','),
        ...rows.map(row => 
          reactDataGridColumns.map(col => {
            const value = row[col.key] || '';
            return `"${String(value).replace(/"/g, '""')}"`;
          }).join(',')
        )
      ].join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${baseFilename}.csv`;
      link.click();
      window.URL.revokeObjectURL(url);
      
    } else if (format === 'excel') {
      // Create basic Excel-compatible CSV with BOM for Excel
      const csvContent = '\uFEFF' + [
        headers.join('\t'),
        ...rows.map(row => 
          reactDataGridColumns.map(col => {
            const value = row[col.key] || '';
            return String(value).replace(/\t/g, ' ');
          }).join('\t')
        )
      ].join('\n');

      const blob = new Blob([csvContent], { type: 'text/tab-separated-values' });
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${baseFilename}.xls`;
      link.click();
      window.URL.revokeObjectURL(url);
      
    } else if (format === 'json') {
      const jsonData = rows.map(row => {
        const obj = {};
        reactDataGridColumns.forEach(col => {
          obj[col.name] = row[col.key];
        });
        return obj;
      });

      const jsonContent = JSON.stringify(jsonData, null, 2);
      const blob = new Blob([jsonContent], { type: 'application/json' });
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${baseFilename}.json`;
      link.click();
      window.URL.revokeObjectURL(url);
    }
  }, [rows, reactDataGridColumns, getExportFilename]);

  // State for temporary display data that includes edits
  const [tempDisplayData, setTempDisplayData] = useState([]);
  
  // Get display data (paginated for client-side, raw for server-side)
  const displayData = useMemo(() => {
    const baseData = serverPagination ? rows : pagination.paginatedData;
    console.log('üìä GenericTableFast displayData calculation:', {
      serverPagination,
      rowsLength: rows.length,
      paginatedDataLength: pagination.paginatedData.length,
      baseDataLength: baseData.length,
      newRowTemplate: !!newRowTemplate
    });
    
    if (!newRowTemplate) return baseData;
    
    // Add blank rows at the end for new entries
    const blankRows = Array.from({ length: 20 }, (_, i) => ({
      ...newRowTemplate,
      _id: `blank_${i}`, // Temporary ID for React keys
      _isNew: true
    }));
    
    const result = [...baseData, ...blankRows];
    console.log('üìä Final display data:', {
      totalLength: result.length,
      realRows: baseData.length,
      blankRows: blankRows.length
    });
    return result;
  }, [serverPagination, rows, pagination.paginatedData, newRowTemplate]);

  // Imperative handle for external control
  useImperativeHandle(ref, () => ({
    save: handleSave,
    delete: handleDelete,
    export: handleExport,
    refresh: fetchData,
    isDirty,
    getSelectedRows: () => {
      const selectedRowIds = Array.from(selectedRows);
      return rows.filter(row => selectedRowIds.includes(row.id || row._id));
    },
    clearSelection: () => setSelectedRows(new Set())
  }));

  if (loading) {
    return (
      <div className="d-flex justify-content-center align-items-center" style={{ height }}>
        <div className="spinner-border text-primary" role="status">
          <span className="visually-hidden">Loading...</span>
        </div>
      </div>
    );
  }

  return (
    <div className={`generic-table-fast ${className} theme-${theme}`} style={{ height }}>
      {/* Professional Table Toolbar */}
      <TableToolbar 
        tableControlsProps={{
          columns: finalColumns,
          colHeaders: finalHeaders,
          visibleColumns: reactDataGridColumns,
          quickSearch,
          setQuickSearch,
          unsavedData: serverPagination ? rows : filteredData,
          hasNonEmptyValues: (row) => row && Object.values(row).some(value => value !== null && value !== undefined && value !== ''),
          selectedCount: selectedRows.size,
          pagination: serverPagination ? {
            totalCount: serverTotalCount,
            currentPage: 1,
            totalPages: Math.ceil(serverTotalCount / rows.length),
            data: rows,
            displayedRows: rows.length
          } : {
            currentPage: pagination.currentPage,
            totalPages: pagination.totalPages,
            pageSize: pagination.pageSize,
            totalRows: rows.length, // Total before filtering
            startRow: pagination.startRow,
            endRow: pagination.endRow,
            filteredRows: filteredData.length // After filtering
          },
          data: filteredData,
          onFilterChange: handleFilterChange,
          columnFilters,
          apiUrl,
          serverPagination,
          dropdownSources,
          isDirty
        }}
      />
      
      {/* Action Buttons Row */}
      {((onSave || saveUrl) || (onDelete || deleteUrl) || getExportFilename || columnActions.length > 0) && (
        <div className="table-action-controls d-flex gap-2 align-items-center px-3">
          {(onSave || saveUrl) && (
            <button 
              className={`action-btn ${isDirty ? 'action-btn-primary' : 'action-btn-secondary'}`}
              onClick={handleSave}
              disabled={!isDirty || loading}
            >
              Save {isDirty ? '(*)' : ''}
            </button>
          )}
          
          {(onDelete || deleteUrl) && selectedRows.size > 0 && (
            <button 
              className="action-btn action-btn-danger"
              onClick={async () => {
                const selectedRowObjects = Array.from(selectedRows)
                  .map(id => rows.find(row => (row.id || row._id) === id))
                  .filter(Boolean);
                
                if (window.confirm(`Delete ${selectedRowObjects.length} selected row(s)?`)) {
                  await handleDelete(selectedRowObjects);
                }
              }}
              disabled={loading}
            >
              Delete ({selectedRows.size})
            </button>
          )}
          
          {getExportFilename && (
            <div className="dropdown">
              <button 
                className="action-btn action-btn-secondary dropdown-toggle"
                type="button"
                data-bs-toggle="dropdown"
                aria-expanded="false"
                disabled={loading}
              >
                Export
              </button>
              <ul className="dropdown-menu">
                <li>
                  <button 
                    className="dropdown-item"
                    onClick={() => handleExport('csv')}
                    disabled={loading}
                  >
                    Export as CSV
                  </button>
                </li>
                <li>
                  <button 
                    className="dropdown-item"
                    onClick={() => handleExport('excel')}
                    disabled={loading}
                  >
                    Export as Excel
                  </button>
                </li>
                <li>
                  <button 
                    className="dropdown-item"
                    onClick={() => handleExport('json')}
                    disabled={loading}
                  >
                    Export as JSON
                  </button>
                </li>
              </ul>
            </div>
          )}
          
          {columnActions.length > 0 && (
            <div className="dropdown">
              <button 
                className="action-btn action-btn-secondary dropdown-toggle"
                type="button"
                data-bs-toggle="dropdown"
                aria-expanded="false"
                disabled={loading}
              >
                Columns
              </button>
              <ul className="dropdown-menu">
                {columnActions.map((action, index) => (
                  <li key={index}>
                    <button 
                      className="dropdown-item"
                      onClick={action.onClick}
                      disabled={loading}
                    >
                      {action.icon && <span className="me-2">{action.icon}</span>}
                      {action.text}
                    </button>
                  </li>
                ))}
              </ul>
            </div>
          )}
          
          <button 
            className="action-btn action-btn-secondary"
            onClick={fetchData}
            disabled={loading}
            title="Refresh data"
          >
            Refresh
          </button>
          
          <div className="ms-auto d-flex align-items-center gap-2">
            {loading && <div className="spinner-border spinner-border-sm" />}
          </div>
        </div>
      )}

      {/* The blazing fast table */}
      <div 
        className="table-grid-wrapper"
        style={{ 
          borderRadius: '0',
          overflow: 'hidden',
          backgroundColor: 'var(--table-bg, #ffffff)',
          margin: '0'
        }}>
        <ReactDataGrid
          columns={reactDataGridColumns}
          rowGetter={i => displayData[i] || {}}
          rowsCount={displayData.length}
          onGridRowsUpdated={({ fromRow, toRow, updated, action }) => {
            console.log('üìù Cell updated:', { fromRow, toRow, updated, action });
            
            // Update the rows directly
            const newRows = [...rows];
            for (let i = fromRow; i <= toRow; i++) {
              if (displayData[i] && !displayData[i]._isNew) {
                const rowIndex = newRows.findIndex(row => row.id === displayData[i].id);
                if (rowIndex >= 0) {
                  newRows[rowIndex] = { ...newRows[rowIndex], ...updated };
                }
              }
            }
            
            // Handle new rows (blank rows that got data)
            for (let i = fromRow; i <= toRow; i++) {
              if (displayData[i] && displayData[i]._isNew) {
                // Check if this blank row now has meaningful data
                const hasData = Object.entries(updated).some(([key, value]) => 
                  key !== '_id' && key !== '_isNew' && 
                  value !== null && value !== undefined && value !== ''
                );
                
                if (hasData) {
                  const newRow = { ...displayData[i], ...updated };
                  delete newRow._isNew;
                  delete newRow._id;
                  newRows.push(newRow);
                }
              }
            }
            
            setRows(newRows);
            setIsDirty(true);
            console.log('üìù Updated rows:', newRows.length);
          }}
          enableCellSelect={true}
          enableCellAutoFocus={true}
          cellNavigationMode="CHANGE_ROW"
          className={`rdg rdg-${theme}`}
          rowHeight={42}
          headerRowHeight={50}
        />
      </div>
      
      {/* Professional Pagination Footer */}
      {!serverPagination && filteredData.length > 0 && (
        <PaginationFooter
          currentPage={pagination.currentPage}
          totalPages={pagination.totalPages}
          pageSize={pagination.pageSize}
          totalItems={filteredData.length}
          onPageChange={pagination.handlePageChange}
          onPageSizeChange={pagination.handlePageSizeChange}
          loading={loading}
        />
      )}
    </div>
  );
});

GenericTableFast.displayName = 'GenericTableFast';

export default GenericTableFast;